//------------------------------------------------
//--- 010 Editor v12.0.1 Binary Template
//
//      File: IP
//   Authors: Hell
//   Version: 1.0.0
//   Purpose: 
//  Category: 
// File Mask: 
//  ID Bytes: 
//   History: 
//------------------------------------------------

typedef enum<ubyte> 
{  
    IPPROTOCOL_ICMP = 1,
    IPPROTOCOL_TCP = 6,
    IPPROTOCOL_UDP = 17,
}IPPROTOCOL;

typedef struct{
    byte Version:4 <comment="IP packet version">;
    byte Size:4 <name="Header Length", comment=IPv4HeaderComment>;
    byte DiffServiceField;
    WORD TotalLength;
    WORD Identification <format=hex>;
    WORD Flags:3;
    WORD FragmentOffset:13;
    ubyte TTL <comment="Time To Live">;
    enum IPPROTOCOL Protocol;
    WORD CheckSum <format=hex, comment=IPv4PacketCheckSumComment>;
    DWORD SrcAddress <format=hex, comment=IPv4AddressToString>;
    DWORD DstAddress <format=hex, comment=IPv4AddressToString>;
    if(Size * 4 - 20 != 0)
    {
        byte ExtendData[Size*4-20] <format=hex>;
    }
}IPV4_HEADER;

typedef struct{
}IPV6_HEADER;

typedef struct(byte version) {
    if(version == 4)
    {
        IPV4_HEADER Header;
    }
    else if(version == 6)
    {
        IPV6_HEADER Header;
    }
}IP_HEADER;

typedef struct(WORD size){
    ubyte Type;
    ubyte Code;
    WORD CheckSum <format=hex>;
    WORD Identifier <format=hex>;
    WORD SequenceNumber <format=hex>;
    byte Data[size-8] <format=hex>;
}ICMP_HEADER;

string IPv4HeaderComment(byte &size)
{
    string comment;
    SPrintf(comment, "IP Head szie %d", size * 4);
    return comment;
}

string IPv4AddressToString(DWORD address)
{
    DWORD a, b, c, d;
    a = (address & 0xFF000000) >> 24;
    b = (address & 0xFF0000) >> 16;
    c = (address & 0xFF00) >> 8;
    d = (address & 0xFF);
    string comment;
    SPrintf(comment, "%d.%d.%d.%d", a, b, c, d);
    return comment;
}

WORD CalcCheckSum(ubyte data[], int64 size)
{
    local DWORD result = 0;
    local int64 i = 0;
    local USHORT v = 0;
    for (i = 0; i < size; i += 2)
    {
        if (size - i == 1)
        {
            v = data[i];
        }
        else
        {
            v = ((WORD)data[i] << 8) | (WORD)data[i+1];
        }
        result += (DWORD)v;
    }

    local DWORD high_data;
    for(i = 0; i < 10; i++){
        high_data = (result & 0xFFFF0000)>>16;
        if(high_data == 0)
        {
            break;
        }

        result = result & 0xFFFF;
        result += high_data;
    }

    return ~result;
}

WORD IPv4PacketCalcCheckSum()
{
    local ubyte ipv4_data[ip_header.Header.Size*4];
    ReadBytes(ipv4_data, file_start_pos, ip_header.Header.Size*4);
    ipv4_data[10] = 0;
    ipv4_data[11] = 0;
    local WORD checksum = CalcCheckSum(ipv4_data, ip_header.Header.Size*4);
    return checksum;
}

string IPv4PacketCheckSumComment(WORD origin_checksum)
{
    string comment;
    WORD calc_checksum = IPv4PacketCalcCheckSum();
    if(calc_checksum == origin_checksum)
    {
        SPrintf(comment, "correct");
    }
    else
    {
        SPrintf(comment, "incorrect, should be 0x%X", calc_checksum);
    }
    return comment;
}

// Start Parse
BigEndian();
Printf("Start parse IP packet\n");
local int64 file_start_pos = OffsetGetStart();
byte ip_version:4 <hidden=true>;
local IPPROTOCOL g_protocol;
FSeek(file_start_pos);
IP_HEADER ip_header(ip_version);

if(ip_header.Header.Protocol == IPPROTOCOL_ICMP)
{
    ICMP_HEADER icmp_header(ip_header.Header.TotalLength - ip_header.Header.Size * 4);
}
else if(ip_header.Header.Protocol == IPPROTOCOL_TCP)
{
    
}
else
{
    Printf("Unknown IPPROTOCOL : %d\n", ip_header.Header.Protocol);
    return -1;
}
